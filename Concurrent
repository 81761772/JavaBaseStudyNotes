1.并行和并发：并行是指多个任务在同一时刻同时运行，并发是指多个任务在一段时间内先后运行；
  由一个单核处理器单独处理多个任务时，虽然看起来是多个任务同时运行，但实际上是利用时间片的分发进行并发运行，故该情况不存在并行；
  有多个处理器或一个多核处理器处理多个任务时，存在并行情况。
  
2.形象诠释：一个线程对象（Thread）携带着一个任务（继承于Runnable的类）访问资源（如生产者-消费者模型中的共享资源池中的变量）并向前运行直到任务完成。
  注：《Thinking in Java》中建议将Runnable改为Task很有道理。

3.异常不能跨线程传播回main(),JVM的这种设计源自于这样一种理念：“线程是独立执行的代码片断，线程的问题应该由线程自己来解决，而不要委托到外部。”
  故在Java中，线程方法的异常（无论是checked还是unchecked exception），都应该在线程代码边界之内（run方法内）被处理掉。

4.Java中的线程可以分为两类：用户线程(User Thread)和守护线程(Daemon Thread,又称后台线程)。这种分类机制是因JVM而存在的，守护线程具有
  最低的优先级，为系统中的其它对象和线程提供服务。将一个用户线程设置为守护线程的方式是在该用户线程对象创建之前调用它的setDaemon(true)方法。
  典型的守护线程例子是JVM中的系统资源自动回收线程，我们所熟悉的Java垃圾回收线程就是一个典型的守护线程，当我们的程序中不再有任何运行中的Thread，
  程序就不会再产生垃圾，垃圾回收器也就无事可做，所以当垃圾回收线程是Java虚拟机上仅剩的线程时，Java虚拟机会自动离开。当JVM中所有线程都是守护线程
  时，JVM就可以退出了，如果还有一个或以上的非守护线程则JVM不会退出。

5.守护线程创建的任何线程将被自动设置成守护线程。

6.同步监听器（同步监听锁对象）：一个代码区域，这个区域在一段时间内只能被一个线程访问。如生产者-消费者模型中的共享资源池。
  判别方式：
  （1）synchronized修饰方法：
　　   ①修饰非静态方法：默认同步监听器对象是this
　　   ②修饰静态方法：默认同步监听器对象是该方法所在类的Class对象，如Class a = xxx.class
  （2）若线程是实现方式（implements）:
　     ①同步代码块：同步监听对象可以选this，也可以使用该类的Class对象，也可以选一个不变的对象；
       ②同步方法：可以直接使用synchronized修饰run()方法，因为此时默认的同步监听对象是this;
  （3）若线程是继承方式（extends）：
       ①同步代码块：可以使用该类的Class对象，也可以选一个不变的对象；
　　　　②同步方法：不能使用synchronized修饰run()方法;
 
7.wait()和notify()方法只能被同步监听器对象调用。

8.Lock机制不存在同步锁的概念，故不能使用wait()和notify()方法实现线程通信，解决方法是实现Condition接口并调用相关方法。
