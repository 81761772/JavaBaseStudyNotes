1.
  for(int i = first;i < last;i++){
      if(Condition){
          return target;
      }
      return -1;
  }

  注意以上用法：for循环会一直进行，直到条件Condition得到满足，此时返回target，跳出for循环（需要注意的是，假如第一次循环和第二次循环都满足
  Condition条件时，循环会在第一次跳出，而不执行第二次循环）。若一直到循环结束Condition都没有得到满足，则返回-1。

2.目前来看，Java中不存在指针，而用引用来代替。

3.equals()方法用于比较两个对象引用所指的内容是否相等，而“==”运算符比较的是两个对象引用的地址是否相等。

4.多态即对象类型的多种形态。

5.Java中字段即成员。

6.Java规定不能将方法体内的局部变量声明为static类型。

7.接口中定义的字段（如常量）必须赋予初值，因为在接口中定义的任何字段都是被static和final修饰的，而被final修饰的字段必须有初值。

8.在接口中定义的方法必须被定义为public或abstract形式。

9.被定义为final的常量定义时需要使用大写字母命名，并且中间使用下划线进行连接。

10.在内部类中可以随意使用外部类的成员，即使这些成员被修饰为private。

11.在一个编译单元（源文件）中只能有一个被修饰为public的类，且文件名应为该类名；当编译单元内无public类时，可随意给文件命名。

12.关于singleton模式：
   eg:    class Test{
              private Test(){}
              private static Test t = new Test();
              public static Test access(){
                  return t;
              }
          }
   由于Test()类的唯一的构造方法被修饰为private，故无法通过"new"的方式创建对象，所以只能通过access()方法返回一个对象引用，这种模式避免了类在
   外部被实例化，且保证了该类只有一个实例存在。

13.构建一个子类对象时，先执行其父类的构造方法，再执行自身的构造方法；除构造器外，编译器禁止在其他任何方法中调用构造器；尽管可以用this调用一个构造器，
  但不能调用多个，而且必须将构造器调用语句置于起始处。

14.类的每个成员保证都会有一个初始值（对象引用初始值为NULL),但对于方法的局部变量，Java则不会提供初始值。

15.可以在构造器中进行初始化，但构造器外的初始化优先于构造器内的初始化。

16.静态对象初始化优先于非静态对象初始化。

17.匿名内部类与普通内部类在实现向上转型为接口上有异曲同工之妙，普通内部类将实例化后的内部类对象赋给接口类型的引用以实现向上转型，而匿名内部类直接在
   addActionListener()方法的括号内返回一个接口类型的匿名内部类对象，如下例eg:
   JButton jb = new JButton();
   jb.addActionListener(new ActionListener){//括号内直接实例化了一个接口类型，省去了将实例化结果赋给接口类型的引用这一步
       public void actionPerformed(ActionEvent arg0){
       }
   );

18.关于传递可变参数：eg: public Example(String...strings)
   即调用时参数个数是可变的。

19.需实现无限循环可用“while(true)”或“for(;;)”。

20.Java中不支持多继承。



21.对象存储在堆中，对象引用存储在堆栈中，基本类型（如int）存储在堆栈中，封装类（如Integer）存储在堆中。

22.类的成员变量即使没有进行初始化也会获得一个默认值，但局部变量（如方法中定义的变量）不会。

23.C语言的函数名不能重复，而Java可以对函数（方法）进行重载。

24.现有一个方法：void exam(datatype n)，当调用该方法时传入参数的类型若小于datatype则自动提升，若大于datatype则需进行窄化转换。
   Java类型由低字节到高字节提升规律如下：byte->short->int->long->float->double，char类型直接提升到int类型。
